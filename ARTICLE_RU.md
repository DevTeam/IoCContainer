# Обзор библиотеки IoC.Container

Эта статья будет интересна, в первую очередь, .NET разработчикам, которые используют в своих проектах принцип [TDD](https://en.wikipedia.org/wiki/Test-driven_development) или просто модульные тесты и хотят, чтобы их код оставался простым и работал эффективно.

Написание модульных тестов, теоретически, должно увеличивать время, затраченное на создание продукта, и, соответственно, его стоимость. На практике это предположение чаще всего не верно в контексте создания и сопровождения продукта в целом вот почему: 
- обычно код тестов прост, однотипен и пишется быстро. Современные фреймворки для тестирования ([NUnit](https://nunit.org/), [XUnit](https://xunit.github.io/) и т.д.) и _"мокирования"_ ([Moq](https://github.com/moq/moq4), [NSubstitute](http://nsubstitute.github.io/) и др.) значительно упрощают создание тестов и даже делают увлекательным
- программисты люди ленивые, но креативные. Написание модульных тестов помогает сконцентрироваться на ответственности класса или структуры и четко обозначить список решаемых задач. Подталкивает соблюдать принцип _"Вам это не понадобится"_ [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) и тем самым, несколько, притупляет _"креативность"_ программиста. А это, в свою очередь, позволяет сделать меньше работы, для достижения того же результата, чему _"ленивая"_ сторона программиста будет рада. Очевидно, меньшее количество кода, будет содержать меньшее количество ошибок в нем
- отличным бонусом будет и контроль регрессии. Любое изменение в коде будет автоматически проверено, например, процессом непрерывной интеграции, на непротиворечивость требованиям и корректности выполнения задач. Станет ощутимо проще и быстрее искать и устранять дефекты в коде, так как упавший тест будет точно указывать какая логика сломалась. Новые фичи будут появляться быстрее и будет проще рефакторить код, не боясь что-то разломать. Своевременный рефакторинг кода не допустит его деградации: усложнения, _“копи-пастов”_, отставания от современных тенденций
- уменьшится количество других видов тестов, в том числе и особо затратных по времени, таких как _интеграционные_. Это значительно сократить время от внесения каких-либо изменений в код до готовности использовать результаты этих изменений
- дизайн проекта преобразится в лучшую сторону, так как использование [TDD](https://en.wikipedia.org/wiki/Test-driven_development) и модульных тестов накладывает на проект определенные требования, такие как: слабая связанность между модулями, следование принципам объекто-ориентированного программирования [SOLID](https://en.wikipedia.org/wiki/SOLID) и д.р.

Главное из требований к модульным тестам заключатся в том, что каждый модуль (в нашем случае класс или структура) должен быть готовым к тестированию в полной изоляции. Другими словами, модульный тест должен проверять работу только одного модуля. Если же тестировать модуль не в полной изоляции, а вместе с его зависимостями, то на результаты тестов будет влиять _"чужая"_ логика из зависимостей. Это сделает невозможным тонкую настройку тестового окружения, значительно увеличит количество тестов, сделает тесты сложными и ломкими. Изменения в модуле будут влиять на результаты тестов для других модулей и в какой-то момент, а это произойдет достаточно быстро, тесты превратятся в тыкву. Что бы избежать этой мрачной картины и протестировать модуль в изоляции, необходимо внедрить все зависимости в модуль из вне. Другими словами, придется отказаться от использования операторов _new_ в логике класса или структуры, заменив их аргументами конструктора, аргументами методов инициализации или свойствами, передаваемыми из вне.

Подход, с непосредственным внедрением зависимостей в экземпляр типа через конструкторы/методы инициализации/поля/свойства, имеет ряд преимуществ и недостатков. Главное преимущество в том, что нет необходимости что-то изобретать - синтаксис языка содержит все необходимое. Напрашивается вопрос: где и когда создавать экземпляры типов и внедрять зависимости, когда типов много и связи между ними сложны? Можно воспользоваться [абстрактной фабрикой](https://en.wikipedia.org/wiki/Abstract_factory_pattern). Появляется другой вопрос: сколько понадобится таких фабрик и как они будут взаимодействовать друг с другом для композиции объектов, в случае сложного графа зависимостей?

Ответ на последний вопрос лежит на поверхности и это [Service Locator](https://en.wikipedia.org/wiki/Service_locator_pattern), который, предоставляет зависимость каждому желающему экземпляру по мере необходимости, через метод разрешения зависимости, такой как _GetService_. Это главное достоинство [Service Locator](https://en.wikipedia.org/wiki/Service_locator_pattern), но одновременно его главный недостаток. Каждый экземпляр может потребовать **любую зависимость** в **любое время**. Другими словами, потенциально, каждый зависит от всех. Реальность еще сложнее - логика класса или структуры в разных условиях может потребовать разный набор зависимостей. Становится очевидной потеря контроля над зависимостями, что делает непростым создание окружения для тестирования в изоляции. Как итог, тесты станут ломкими и их будет не просто поддерживать и развивать. 

Еще один подход это [IoC контейнер](https://martinfowler.com/articles/injection.html). Каждый тип имеет только необходимый и достаточный набор внедряемых зависимостей, определенный в конструкторе, методах инициализации или свойствах, открытых для записи. Казалось бы, все хорошо, бери и используй, но, как всегда, и тут есть ложка дёгтя. Проблема в том, что .NET код создает объекты почти мгновенно, используя операторы _new_. Скорость их создания, как _"скорость света в вакууме"_, это порог, который невозможно преодолеть, используя какой-либо фреймворк. Каждая реализация [IoC контейнера](https://martinfowler.com/articles/injection.html) использует свой собственный механизм разрешения и внедрения зависимостей. Можно выделить несколько, добавив один главный недостаток для каждого: 
- волшебный статический метод [Activator.CreateInstance](https://docs.microsoft.com/en-us/dotnet/api/system.activator.createinstance) - **низкая производительность**
- сопоставление типов и лямбда функций для создания экземпляров этих типов - **нет авто-связывания**, т.е. придется обозначить весь процесс создания экземпляров вручную, передав все зависимости как аргументы в конструктор, в метод инициализации или в свойство, открытое для записи
- генерация кода 
  - создание текста кода и его компиляция - **низкая скорость генерации и компиляции**
  - использование синтаксического дерева [Roslyn](https://github.com/dotnet/roslyn)/[CodeDOM](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/using-the-codedom) - **зависимость от большого набора библиотек**
  - использование [Expression Trees](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/) - **нет полного контроля генерируемого кода**
  - [генерация IL кода](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.ilgenerator) - **сложность реализации и отладки**

Любой из этих подходов будет создавать экземпляры медленнее _“скорости света в вакууме”_ - набора операторов _new_. Если вспомнить, что [IoC контейнер](https://martinfowler.com/articles/injection.html) - всего лишь инфраструктура, которая не делает ни чего полезного в контексте основных задач, то ради неё не хочется жертвовать производительностью. Можно пойти на компромисс и использовать [IoC контейнеры](https://martinfowler.com/articles/injection.html) выборочно: xасть типов, количество экземпляров которых не велико, создаются с использованием [IoC контейнера](https://martinfowler.com/articles/injection.html), остальные - как-то по-другому. Этот компромиссный вариант выглядит не плохо, в целом же, решение будет не идеальным. Так же можно попытаться выбрать [IoC контейнер](https://martinfowler.com/articles/injection.html) побыстрее, например, воспользовавшись [ссылкой](https://github.com/danielpalme/IocPerformance). В этих сравнительных тестах есть нюансы: в [тестовых сценариях](https://github.com/danielpalme/IocPerformance/blob/c9924f26d0ab33977adc73909d9e305f538ec87d/IocPerformance/Benchmarks/Basic/02_Transient_Benchmark.cs#L15) измеряется производительность огромного числа вызовов методов  _GetService_ или _Resolve_, которых в реальных сценариях должно быть совсем не много. _"Скорость света"_ измерена не _"в вакууме"_, так как для работы _“без контейнерного”_ варианта используется [некая структура данных](https://github.com/danielpalme/IocPerformance/blob/master/IocPerformance/Adapters/NoContainerAdapter.cs#L16), определяющая соответствие типов, использующихся для разрешения зависимостей, что в реальной жизни мало кто будет делать - всегда можно просто создать экземпляр этого типа, используя конструктор. Экземпляры типов возвращаются как _Object_, что приводит к лишним операциям приведения типа и отрицательно сказывается на производительности.

Практические все более-менее быстрые фреймворки используют какую-то генерацию кода, остановимся на одном из них. Основными целями создания [IoC.Container](https://github.com/DevTeam/IoCContainer) были простота, гибкость, возможности расширения и, главное, скорость - минимизация накладных расходов по созданию множества экземпляров типов.  Этот фреймворк использует [Expression Trees](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/) при генерации IL кода для разрешения и внедрения зависимостей. Вот [простой пример](https://dotnetfiddle.net/dRebQM) его использования:

- перед вами [Кот Шрёдингера](https://en.wikipedia.org/wiki/Schr%C3%B6dinger%27s_cat)

![image](https://github.com/DevTeam/IoCContainer/raw/master/Docs/Images/cat.jpg?raw=true)

- создадим абстракцию

```CSharp
interface IBox<out T> { T Content { get; } }

interface ICat { State State { get; } }

enum State { Alive, Dead }
```

- и реализацию для этой абстракции

```CSharp
class CardboardBox<T> : IBox<T>
{
    public CardboardBox(T content) => Content = content;

    public T Content { get; }

    public override string ToString() { return "[" + Content + "]"; }
}

class ShroedingersCat : ICat
{
    public ShroedingersCat(State state) { State = state; }

    public State State { get; private set; }

    public override string ToString() { return State + " cat"; }
}
```

- добавим зависимость на пакет [![NuGet](https://buildstats.info/nuget/IoC.Container)](https://www.nuget.org/packages/IoC.Container)

  - Package Manager
```Install-Package IoC.Container```
  - .NET CLI
```dotnet add package IoC.Container```

- и _"клей"_, который свяжет абстракцию с реализацией

```CSharp
class Glue : IConfiguration
{
  public IEnumerable<IDisposable> Apply(IContainer container)
  {
    yield return container.Bind<IBox<TT>>().To<CardboardBox<TT>>();
    yield return container.Bind<ICat>().To<ShroedingersCat>();

    var rnd = new Random();
    yield return container.Bind<State>().To(_ => (State)rnd.Next(2));
  }
}
```

- пока наш _"полезный"_ код не подозревает о наличии [IoC.Container](https://github.com/DevTeam/IoCContainer), используем _"клей"_ и создаем экземпляр типа _Program_, внедряя зависимости через его конструктор

```CSharp
using (var container = Container.Create().Using<Glue>())
{
  container.BuildUp<Program>();
}
```

- настало время открывать _"коробки"_ большие и маленькие, с бантиками и без!!!

```CSharp
public Program(
  ICat cat,
  IBox<ICat> box,
  IBox<IBox<ICat>> bigBox,
  Func<IBox<ICat>> func,
  Task<IBox<ICat>> task,
  Tuple<IBox<ICat>, ICat, IBox<IBox<ICat>>> tuple,
  Lazy<IBox<ICat>> lazy,
  IEnumerable<IBox<ICat>> enumerable,
  IBox<ICat>[] array,
  IList<IBox<ICat>> list,
  ISet<IBox<ICat>> set,
  IObservable<IBox<ICat>> observable,
  IBox<Lazy<Func<IEnumerable<IBox<ICat>>>>> complex,
  ThreadLocal<IBox<ICat>> threadLocal,
  ValueTask<IBox<ICat>> valueTask,
  (IBox<ICat> box, ICat cat, IBox<IBox<ICat>> bigBox) valueTuple) { ... }
```
Важно отметить, что полезный код не знает ни чего о [IoC.Container](https://github.com/DevTeam/IoCContainer), а [IoC.Container](https://github.com/DevTeam/IoCContainer) не влияет на полезный код. Для создания графа объектов с экземпляром типа _Program_ в корне, [IoC.Container](https://github.com/DevTeam/IoCContainer) создает и компилирует _IL_ код эквивалентный:

```CSharp
new Program(new ShroedingersCat(), new CardboardBox<ShroedingersCat>(new ShroedingersCat()), ...);
```

который оказывает минимальное влияние на производительность создания графа объектов. Это небольшое влияние оказывается из-за того, что:
- какое-то время уходит на компиляцию кода из [Expression Trees](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/expression-trees/)
- скомпилированный код находится в теле лямбда функции, на вызов которых тратится время

Нидже приведены [результаты тестов](http://tcavs2015.cloudapp.net/repository/download/DevTeam_IoCContainer_CreateReports/1070:id/REPORT.html) для разных фреймворков под _.net core 2.1_

**20 объектов и 1 синглтон 10 миллионов раз**

| IoC | Время (мс)|
| --- | --- |
| операторы _new_ | **89** |
| IoC.Container 1.1.10 в реальном сценарии | **175** |
| IoC.Container 1.1.10 | 328 |
| LightInject 5.1.8 | 392 |
| DryIoc 3.0.2 | 412 |
| Castle Windsor 4.1.0 | 4070 |
| Unity 5.8.6 | 53600 |
| Autofac 4.8.1 | 141500 |
| Ninject 3.3.4 | 1350000 |

**27 объектов 10 миллионов раз**

| IoC | Время (мс)|
| --- | --- |
| операторы _new_ | **63** |
| IoC.Container 1.1.10 в реальном сценарии | **106** |
| IoC.Container 1.1.10 | 285 |
| DryIoc 3.0.2 | 329 |
| LightInject 5.1.8 | 441 |
| Castle Windsor 4.1.0 | 3890 |
| Unity 5.8.6 | 56800 |
| Autofac 4.8.1 | 190800 |
| Ninject 3.3.4 | 1734000 |

Здесь _"реальный сценарий"_ - это сценарии, наиболее близкий к честному внедрению зависимостей. Результаты сравнительного тестирования и пример использования показывают, что эффективность современных [IoC контейнеров](https://martinfowler.com/articles/injection.html) позволяет использовать многие из них и в проектах с особыми требованиями к производительности, без усложнения кода, применяя [TDD](https://en.wikipedia.org/wiki/Test-driven_development) и/или используя модульные тесты.
